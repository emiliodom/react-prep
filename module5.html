<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Module 5: Advanced Patterns</title>
    <link rel="stylesheet" href="styles.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
</head>
<body>
    <header>
        <h1>Module 5: Advanced Patterns</h1>
        <p>Custom Hooks, Reducers, and Performance.</p>
    </header>

    <nav>
        <!-- Navigation injected by layout.js -->
    </nav>

    <main>
        <h2>1. Core Concepts</h2>
        <p><strong>Custom Hooks:</strong> JavaScript functions that start with <code>use...</code> and call other hooks. They allow you to share <em>logic</em> (like fetching or form handling) between components without sharing UI.</p>
        <p><strong>useReducer:</strong> An alternative to <code>useState</code> for complex logic. You dispatch "actions" (instructions) to a "reducer" (function) that calculates the new state.</p>
        <p><strong>Memoization (useMemo/useCallback):</strong> Performance tools. They tell React: "If these inputs haven't changed, don't re-calculate this value or re-create this function."</p>

        <h3>1.1 Deep Dive: The Rules of Hooks</h3>
        <p>Hooks are magic, but they have rules. They rely on call order.
        <br>1. Only call hooks at the top level. Never inside loops, conditions, or nested functions.
        <br>2. Only call hooks from React functions.</p>

        <h3>1.2 Industry Standard: The "use" Prefix</h3>
        <p>If a function uses a hook, it <strong>must</strong> be named <code>useSomething</code>. This is not just a convention; linters rely on it to enforce the Rules of Hooks. If you write a helper function that calls <code>useContext</code> but name it <code>getAuth()</code>, you will break the linter and potentially your app.</p>

        <details>
            <summary><strong>üìö Deep Dive (Documentation)</strong></summary>
            <ul>
                <li><a href="https://react.dev/learn/reusing-logic-with-custom-hooks" target="_blank">Custom Hooks</a></li>
                <li><a href="https://react.dev/reference/react/useReducer" target="_blank">useReducer</a></li>
                <li><a href="https://react.dev/reference/react/useMemo" target="_blank">useMemo</a> & <a href="https://react.dev/reference/react/useCallback" target="_blank">useCallback</a></li>
            </ul>
        </details>

        <div class="jira-ticket">
            <div class="jira-header">
                <span class="jira-id">REQ-006</span>
                <span class="jira-status">To Do</span>
            </div>
            <div class="jira-body">
                <h3 class="jira-title">Refactor to Custom Hooks</h3>
                
                <div class="jira-section">
                    <span class="jira-label">User Story</span>
                    <p>As a developer, I want to reuse logic across components so that I don't violate DRY (Don't Repeat Yourself) principles.</p>
                </div>

                <div class="jira-section">
                    <span class="jira-label">Acceptance Criteria</span>
                    <ul class="req-list">
                        <li><strong>useFetch(url):</strong>
                            <ul>
                                <li>Accepts a URL string.</li>
                                <li>Returns <code>{ data, loading, error }</code>.</li>
                                <li>Handles <code>AbortController</code> to cancel requests on unmount.</li>
                            </ul>
                        </li>
                        <li><strong>useLocalStorage(key, initialValue):</strong>
                            <ul>
                                <li>Syncs state with <code>localStorage</code>.</li>
                                <li>Updates storage when state changes.</li>
                                <li>Initializes from storage if available.</li>
                            </ul>
                        </li>
                    </ul>
                </div>

                <div class="jira-section">
                    <span class="jira-label">Senior Bonus</span>
                    <ul class="req-list">
                        <li><strong>Generics:</strong> Make <code>useFetch&lt;T&gt;</code> and <code>useLocalStorage&lt;T&gt;</code> type-safe.</li>
                        <li><strong>useWindowSize:</strong> Create a hook that tracks window dimensions. MUST remove the event listener on unmount.</li>
                        <li><strong>useDebounce:</strong> Create a hook to delay API calls in the search bar (500ms delay).</li>
                    </ul>
                </div>
            </div>
        </div>

        <h2>3. The Bug Hunt</h2>
        <div class="bug-hunt">
            <h3>üêõ Scenario: The Expensive Calculation</h3>
            <p><strong>The Setup:</strong></p>
            <pre><code class="language-jsx">function Dashboard({ data }) {
  // This runs on EVERY render, even if 'data' hasn't changed!
  const processedData = expensiveMathOperation(data); 
  return &lt;Chart data={processedData} /&gt;;
}</code></pre>
            <p><strong>The Bug:</strong> The dashboard is laggy because <code>expensiveMathOperation</code> takes 200ms to run, and the component re-renders whenever the parent updates.</p>
            <p><strong>The Task:</strong></p>
            <ol>
                <li>Wrap the calculation in <code>useMemo</code>.</li>
                <li>Explain why <code>useMemo</code> needs a dependency array.</li>
            </ol>
        </div>
    </main>

    <footer>
        <!-- Footer injected by layout.js -->
    </footer>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-jsx.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-tsx.min.js"></script>
    <script src="layout.js"></script>
</body>
</html>
