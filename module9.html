<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Module 9: Performance & Security</title>
    <style>
        body { font-family: system-ui, -apple-system, sans-serif; line-height: 1.6; max-width: 800px; margin: 0 auto; padding: 20px; color: #333; }
        header { border-bottom: 2px solid #333; padding-bottom: 20px; margin-bottom: 20px; }
        nav { background: #f4f4f4; padding: 10px; border-radius: 5px; margin-bottom: 20px; }
        nav a { margin-right: 15px; text-decoration: none; color: #0066cc; font-weight: bold; }
        nav a:hover { text-decoration: underline; }
        .task { background: #e2e3e5; border-left: 5px solid #383d41; padding: 15px; margin: 20px 0; }
        .bug-hunt { background: #f8d7da; border-left: 5px solid #721c24; padding: 15px; margin: 20px 0; }
        code { background: #f4f4f4; padding: 2px 5px; border-radius: 3px; font-family: monospace; }
        footer { margin-top: 50px; border-top: 1px solid #ccc; padding-top: 20px; font-size: 0.9em; color: #666; text-align: center; }
    </style>
</head>
<body>
    <header>
        <h1>Module 9: Performance & Security</h1>
        <p>Optimization, Lazy Loading, and Secure Practices.</p>
    </header>

    <nav>
        <a href="index.html">Home</a>
        <a href="module0.html">0. JS Prep</a>
        <a href="module1.html">1. Fundamentals</a>
        <a href="module2.html">2. Hooks & Lifecycle</a>
        <a href="module3.html">3. Routing & API</a>
        <a href="module4.html">4. State & Forms</a>
        <a href="module5.html">5. Advanced Patterns</a>
        <a href="module6.html">6. Global State</a>
        <a href="module7.html">7. Testing</a>
        <a href="module8.html">8. Pro Workflow</a>
        <a href="module9.html">9. Perf & Security</a>
        <a href="capstone.html">Capstone</a>
    </nav>

    <main>
        <h2>1. Core Concepts</h2>
        <p><strong>Code Splitting (Lazy):</strong> Don't send the entire app to the user at once. Use <code>React.lazy</code> to load heavy pages (like Admin Dashboard) only when the user clicks the link.</p>
        <p><strong>Virtualization:</strong> If you have 10,000 items, the browser will crash trying to draw 10,000 DOM nodes. Virtualization only draws the 10 items currently on screen.</p>
        <p><strong>XSS (Cross-Site Scripting):</strong> Attackers trying to inject JavaScript into your page. React protects you by default, unless you use <code>dangerouslySetInnerHTML</code>. Always sanitize user content.</p>

        <h3>1.1 Deep Dive: The Cost of JavaScript</h3>
        <p>A 1MB image loads in parallel. A 1MB JavaScript bundle blocks the main thread while it parses and compiles. This freezes the UI. This is why we split code.
        <br><strong>Metric to watch:</strong> TTI (Time to Interactive). How long until the user can actually click a button?</p>

        <h3>1.2 Deep Dive: Referential Equality</h3>
        <p>Why does <code>React.memo</code> fail sometimes?
        <br>Because in JS, <code>{} === {}</code> is <strong>false</strong>.
        <br>If you pass an object or function as a prop to a memoized component, React sees a "new" prop every render, and re-renders the child anyway.
        <br><strong>The Fix:</strong> Use <code>useMemo</code> for objects and <code>useCallback</code> for functions to preserve the <em>reference</em>.</p>

        <h3>1.3 Industry Standard: Error Boundaries</h3>
        <p>If a component crashes (throws an error), the entire React app unmounts and shows a white screen. This is bad.
        <br>Senior devs wrap major sections (like the Sidebar, the Main Content, or individual Widgets) in <strong>Error Boundaries</strong>. If one widget crashes, the rest of the app stays alive.</p>

        <details>
            <summary><strong>üìö Deep Dive (Documentation)</strong></summary>
            <ul>
                <li><a href="https://react.dev/reference/react/lazy" target="_blank">Code Splitting (React.lazy)</a></li>
                <li><a href="https://react.dev/learn/rendering-lists#keeping-list-items-in-order-with-key" target="_blank">Virtualization Concepts</a></li>
                <li><a href="https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html" target="_blank">OWASP XSS Prevention</a></li>
            </ul>
        </details>

        <h2>2. The Build Challenge: "The Heavy Lifter"</h2>
        <div class="task">
            <h3>Level 1: The Basics</h3>
            <ol>
                <li><strong>Code Splitting:</strong>
                    <ul>
                        <li>Take your "Users" and "About" routes.</li>
                        <li>Implement <code>React.lazy</code> and <code>Suspense</code> so their JS bundles are only loaded when the user navigates to them.</li>
                        <li>Verify this in the Network tab of DevTools.</li>
                    </ul>
                </li>
                <li><strong>Debouncing:</strong>
                    <ul>
                        <li>Create a "Search" input that filters a list.</li>
                        <li>Implement a custom <code>useDebounce</code> hook so the filter logic only runs 500ms after the user stops typing.</li>
                    </ul>
                </li>
            </ol>

            <h3>Level 2: Senior Constraints (Virtualization)</h3>
            <ul>
                <li><strong>Virtualization:</strong>
                    <ul>
                        <li>Create a component that generates 10,000 dummy items.</li>
                        <li>Render them normally and notice the lag.</li>
                        <li>Refactor using <code>react-window</code> or <code>react-virtuoso</code> to render only what is visible.</li>
                    </ul>
                </li>
                <li><strong>Memoization Check:</strong> Ensure your list items are wrapped in <code>React.memo</code> so that scrolling doesn't re-render items that haven't changed.</li>
            </ul>

            <h3>Level 3: Nice to Haves</h3>
            <ul>
                <li><strong>Error Boundary:</strong> Create a class component <code>ErrorBoundary</code> (or use <code>react-error-boundary</code>). Wrap your "Heavy List" component in it. Manually throw an error in the list to see the fallback UI appear.</li>
                <li><strong>Skeleton Loading:</strong> Instead of a simple "Loading..." text, create a "Skeleton" version of your card (gray boxes) to show while data is fetching.</li>
            </ul>
        </div>

        <h2>3. The Bug Hunt</h2>
        <div class="bug-hunt">
            <h3>üêõ Scenario: The XSS Trap</h3>
            <p><strong>The Setup:</strong> Create a component that accepts a string prop and renders it using <code>dangerouslySetInnerHTML</code>.</p>
            <p><strong>The Attack:</strong> Pass a string containing <code>&lt;img src=x onerror=alert(1)&gt;</code> into that prop.</p>
            <p><strong>The Task:</strong></p>
            <ol>
                <li>Witness the alert popping up (XSS successful).</li>
                <li>Install a sanitization library like <code>dompurify</code>.</li>
                <li>Sanitize the input before rendering it to prevent the attack.</li>
            </ol>
        </div>

        <h2>4. Test on your own</h2>
        <div class="task">
            <h3>Verify your Performance</h3>
            <ul>
                <li><strong>Bundle Analyzer:</strong> Run <code>npx vite-bundle-visualizer</code>. Look at the output. Do you see your "Users" page as a separate chunk? If it's merged into <code>index.js</code>, your lazy loading failed.</li>
                <li><strong>Lighthouse Score:</strong> Open Chrome DevTools -> Lighthouse. Run a report. Is your "Performance" score above 90? If not, read the suggestions.</li>
            </ul>
        </div>
    </main>

    <footer>
        <p>Module 9 Complete? You are ready for the Capstone.</p>
    </footer>
</body>
</html>
