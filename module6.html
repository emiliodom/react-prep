<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Module 6: Global State Management</title>
    <style>
        body { font-family: system-ui, -apple-system, sans-serif; line-height: 1.6; max-width: 800px; margin: 0 auto; padding: 20px; color: #333; }
        header { border-bottom: 2px solid #333; padding-bottom: 20px; margin-bottom: 20px; }
        nav { background: #f4f4f4; padding: 10px; border-radius: 5px; margin-bottom: 20px; }
        nav a { margin-right: 15px; text-decoration: none; color: #0066cc; font-weight: bold; }
        nav a:hover { text-decoration: underline; }
        .task { background: #e2e3e5; border-left: 5px solid #383d41; padding: 15px; margin: 20px 0; }
        .bug-hunt { background: #f8d7da; border-left: 5px solid #721c24; padding: 15px; margin: 20px 0; }
        code { background: #f4f4f4; padding: 2px 5px; border-radius: 3px; font-family: monospace; }
        footer { margin-top: 50px; border-top: 1px solid #ccc; padding-top: 20px; font-size: 0.9em; color: #666; text-align: center; }
    </style>
</head>
<body>
    <header>
        <h1>Module 6: Global State Management</h1>
        <p>Redux Toolkit (RTK) and Zustand.</p>
    </header>

    <nav>
        <a href="index.html">Home</a>
        <a href="module0.html">0. JS Prep</a>
        <a href="module1.html">1. Fundamentals</a>
        <a href="module2.html">2. Hooks & Lifecycle</a>
        <a href="module3.html">3. Routing & API</a>
        <a href="module4.html">4. State & Forms</a>
        <a href="module5.html">5. Advanced Patterns</a>
        <a href="module6.html">6. Global State</a>
        <a href="module7.html">7. Testing</a>
        <a href="module8.html">8. Pro Workflow</a>
        <a href="module9.html">9. Perf & Security</a>
        <a href="capstone.html">Capstone</a>
    </nav>

    <main>
        <h2>1. Core Concepts</h2>
        <p><strong>Global State:</strong> When data is needed by many disparate parts of the app (User Profile, Shopping Cart, Theme), Context can be slow or messy. We use libraries.</p>
        <p><strong>Redux Toolkit (RTK):</strong> The industry standard. Uses a central "Store". You "dispatch" actions to modify the store. It's strict, verbose, but very predictable.</p>
        <p><strong>Zustand:</strong> The modern favorite. Much simpler. Just a hook that returns your state and functions to update it. No complex providers needed.</p>

        <h3>1.1 Deep Dive: Prop Drilling vs. Composition</h3>
        <p>Before reaching for Redux, ask: "Can I solve this with Composition?"
        <br>Instead of passing <code>user</code> down 4 levels, can you pass the <code>&lt;Avatar user={user} /&gt;</code> component itself as a prop? This is often cleaner than global state.</p>

        <h3>1.2 Industry Standard: Feature Slices</h3>
        <p>In Redux Toolkit, we organize code by "Feature", not by file type. We don't have a folder for "Actions" and a folder for "Reducers". We have a folder for "Cart" which contains <code>cartSlice.ts</code> (logic) and <code>CartComponent.tsx</code> (UI). This is known as the "Ducks" pattern or "Feature Folder" structure.</p>

        <h3>1.3 Senior Concept: Server State vs. Client State</h3>
        <p><strong>The Anti-Pattern:</strong> Storing <em>everything</em> in Redux/Zustand.
        <br><strong>The Senior Approach:</strong> Distinguish between:
        <br>1. <strong>Client State:</strong> UI state (Is the modal open? What is the theme? What is in the cart?). Use <strong>Zustand/Redux</strong>.
        <br>2. <strong>Server State:</strong> Data from an API (User profile, List of products). This is <em>cache</em>, not state. Use <strong>TanStack Query (React Query)</strong>. It handles caching, deduping, and re-fetching automatically.</p>

        <details>
            <summary><strong>üìö Deep Dive (Documentation)</strong></summary>
            <ul>
                <li><a href="https://redux-toolkit.js.org/introduction/getting-started" target="_blank">Redux Toolkit Quick Start</a></li>
                <li><a href="https://github.com/pmndrs/zustand" target="_blank">Zustand Documentation</a></li>
            </ul>
        </details>

        <h2>2. The Build Challenge: "Shopping Cart"</h2>
        <div class="task">
            <h3>Level 1: Redux Toolkit Implementation</h3>
            <p>Create a <code>store</code> folder.</p>
            <ul>
                <li>Setup a Redux store with a <code>cartSlice</code>.</li>
                <li><strong>State:</strong> <code>items</code> (array of objects: id, name, price, quantity).</li>
                <li><strong>Actions:</strong>
                    <ul>
                        <li><code>addToCart(item)</code>: If item exists, increment quantity. Else add it.</li>
                        <li><code>removeFromCart(id)</code>: Remove item completely.</li>
                        <li><code>updateQuantity({id, quantity})</code>.</li>
                    </ul>
                </li>
                <li><strong>Selectors:</strong>
                    <ul>
                        <li><code>selectCartTotal</code>: Calculate total price.</li>
                        <li><code>selectCartCount</code>: Calculate total number of items.</li>
                    </ul>
                </li>
                <li>Connect this to a "Products" page (add buttons) and a "Cart" page (display items).</li>
            </ul>

            <h3>Level 2: Zustand Migration (Senior Constraint)</h3>
            <p>Now, create a separate branch or folder.</p>
            <ul>
                <li>Re-implement the EXACT same logic using <strong>Zustand</strong>.</li>
                <li><strong>Constraint:</strong> You must use the "Selector" pattern in Zustand too, to avoid re-rendering the component if unrelated state changes.</li>
                <li><code>const items = useStore(state => state.items)</code> (Good) vs <code>const { items } = useStore()</code> (Bad - re-renders on everything).</li>
            </ul>

            <h3>Level 3: Nice to Haves</h3>
            <ul>
                <li><strong>Persistence:</strong> Use Zustand's <code>persist</code> middleware to save the cart to localStorage automatically.</li>
                <li><strong>Toast Notifications:</strong> Create a global "Toast" store. When an item is added to the cart, dispatch a <code>showToast("Added to cart!")</code> action that displays a popup for 3 seconds.</li>
            </ul>
        </div>

        <h2>3. The Bug Hunt</h2>
        <div class="bug-hunt">
            <h3>üêõ Scenario: Mutable State in Redux</h3>
            <p><strong>The Setup:</strong> In a Redux reducer, try to mutate state directly <em>without</em> using Toolkit's `createSlice` (which uses Immer under the hood), or try to mutate a nested object deeply in a way that Redux doesn't detect.</p>
            <p><strong>The Task:</strong></p>
            <ol>
                <li>Understand why Redux requires immutability.</li>
                <li>Write a test case where a component fails to re-render because the object reference didn't change.</li>
            </ol>
        </div>

        <h2>4. Test on your own</h2>
        <div class="task">
            <h3>Verify your Store</h3>
            <ul>
                <li><strong>Selector Check:</strong> Add a log in your Cart Icon component. Update the <em>price</em> of an item in the store (but not the count). Does the Cart Icon (which only shows count) re-render? (It shouldn't).</li>
                <li><strong>Persist Check:</strong> Add items to cart. Close the tab. Re-open. Are items still there?</li>
            </ul>
        </div>
    </main>

    <footer>
        <p>Module 6 Complete? Move to Module 7.</p>
    </footer>
</body>
</html>
